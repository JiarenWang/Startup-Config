export SCCACHE_CACHE_SIZE="50G" 缓存大小
export SCCACHE_DIR="/Volumes/SSD/sccahe" 缓存路径


git push -v origin refs/heads/wjr:refs/heads/wjr  --force 强推命令


https://github.com/apple/swift/blob/main/docs/HowToGuides/GettingStarted.md
// 更新所有git 默认main分支
utils/update-checkout --clone-with-ssh
更新命令有时会失败,是网络原因. 每次运行前以下代理命令执行一下.
export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087

// 注意设置作者
git config user.name "jiaren wang"
git config user.email "jr.w@foxmail.com"

//git 更改最近提交的作者信息
git commit --amend --reset-author

# 修改最后一次提交的 commit 信息和作者, 可单独修改
git commit --amend --message=" " --author="jiangliheng <jiang_liheng@163.com>"

//压缩N个提交
git rebase -i HEAD~N
# Re-run N times, reformatting each commit.

//格式化第一个commit并提交
git-clang-format HEAD~1
git add .
git commit --amend --no-edit
git rebase --continue
git rebase main

//强制提交
git push origin branch1 -f

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 列出所有本地分支和远程分支
$ git branch -a

# 提交暂存区到仓库区
$ git commit -m [message]


// build 
utils/build-script --skip-build-benchmarks \
  --skip-ios --skip-watchos --skip-tvos --swift-darwin-supported-archs "$(uname -m)" \
  --sccache --release-debuginfo --swift-disable-dead-stripping --test


  // CHECK: [[@LINE-1]]:5 |  @LINE会被文件当前的行数替代  CHECK: 冒号后面的文本都会进行匹配


//test
utils/run-test --lit ../llvm-project/llvm/utils/lit/lit.py \
  ../build/Ninja-RelWithDebInfoAssert/swift-macosx-$(uname -m)/test-macosx-$(uname -m) \
  --filter="refactoring/ConvertAsync/basic.swift" -v

  utils/run-test --lit ../llvm-project/llvm/utils/lit/lit.py \
  ../build/Ninja-RelWithDebInfoAssert/swift-macosx-$(uname -m)/test-macosx-$(uname -m) \
  --filter="Constraints/closures.swift" -v


  ../llvm-project/llvm/utils/lit/lit.py -s -vv \
  ../build/Ninja-RelWithDebInfoAssert/swift-macosx-$(uname -m)/test-macosx-$(uname -m) \
  --filter="SourceKit/DocumentStructure/structure.swift" -v

  Failed Tests (4):
  Swift(macosx-arm64) :: Generics/associated_type_anchor_rdar47605019.swift
  Swift(macosx-arm64) :: Index/kinds.swift
  Swift(macosx-arm64) :: SILGen/convenience_init_peer_delegation.swift
  Swift(macosx-arm64) :: SourceKit/CodeFormat/indent-computed-property.swift
  Swift(macosx-arm64) :: SourceKit/DocumentStructure/structure.swift

  test/Constraints/diagnostics.swift
  test/diagnostics/pretty-printed-diagnostics.swift
  test/expr/closure/closures.swift
  validation-test/compiler_crashers_2_fixed/0119-rdar33613329.swift


 @rintaro Please review [ParseDecl.cpp](asdasd)
 
 
 测试标准
 lit llvm i... tool
 RUN 执行命令
 CHECK 检查 
 一般是 diff 比较差异 或者 Check 检查文本
 


 C++
 //在这里typename 和class没区别
 template <typename... identifier> func(identifier paramater) 例子:template<typename T> void swap(T&  t1, &T t2) 调用方式  func<int>((a, b),<int>可以省略,因为可以推断类型
 template <class... identifier> func(identifier paramater) 


//C++ 标准库提供了三种智能指针类型：std::unique_ptr、std::shared_ptr 和 std::weak_ptr 智能指针可处理对其拥有的内存的分配和删除
//std::string 字符串
//使用 vector 替代原始数组:
  vector<string> apples;
  apples.push_back("Granny Smith");

//map字典
map<string, string> apple_color;
apple_color["Granny Smith"] = "Green";

//auto
用 auto 替代显式类型名称
C++11 引入了 auto 关键字，以便可将其用于变量、函数和模板声明中。 auto 会指示编译器推导对象的类型，这样你就无需显式键入类型。 当推导出的类型是嵌套模板时，auto 尤其有用：
map<int,list<string>>::iterator i = m.begin(); // C-style
auto i = m.begin(); // modern C++


//用 constexpr 表达式替代宏
#define SIZE 10 // C-style
constexpr int size = 10; // modern C++

//统一初始化 https://docs.microsoft.com/zh-cn/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-160#uniform-initialization

//Lambda 表达式 等于闭包 https://docs.microsoft.com/zh-cn/cpp/cpp/welcome-back-to-cpp-modern-cpp?view=msvc-160#lambda-expressions
可以将 lambda 表达式 [=](int i) { return i > x && i < y; } 可以读取为“采用类型 int 的单个参数并返回一个布尔值来表示此参数是否大于 x 并且小于 y 的函数”。 请注意，可在 lambda 中使用来自周围上下文的 x 和 y 变量。 [=] 会指定通过值捕获这些变量；换言之，对于这些值，lambda 表达式具有自己的值副本。




//指针 *p
通过访问p->属性

//引用
int &b = a;
此时b就是a的引用，或者称之为别名。如果修改b的值，那么a的值也会相应地发生改变。如b=1,那么a也就会跟着等于1。这种方式在函数传参的时候很常见，如果想函数执行完改变原参数的值，就应该在传参的时候，传入原来的实参的引用。

token tok = nextToken()//这样是拷贝 左右变量没有关联
token &tok = nextToken()//这样是起别名

